# THREE GOLD STARS
# Question 3-star: Elementary Cellular Automaton

# Please see the video for additional explanation.

# A one-dimensional cellular automata takes in a string, which in our
# case, consists of the characters '.' and 'x', and changes it according
# to some predetermined rules. The rules consider three characters, which
# are a character at position k and its two neighbours, and determine
# what the character at the corresponding position k will be in the new
# string.

# For example, if the character at position k in the string  is '.' and
# its neighbours are '.' and 'x', then the pattern is '..x'. We look up
# '..x' in the table below. In the table, '..x' corresponds to 'x' which
# means that in the new string, 'x' will be at position k.

# Rules:
#          pattern in         position k in        contribution to
# Value    current string     new string           pattern number
#                                                  is 0 if replaced by '.'
#                                                  and value if replaced
#                                                  by 'x'
#   1       '...'               '.'                        1 * 0
#   2       '..x'               'x'                        2 * 1
#   4       '.x.'               'x'                        4 * 1
#   8       '.xx'               'x'                        8 * 1
#  16       'x..'               '.'                       16 * 0
#  32       'x.x'               '.'                       32 * 0
#  64       'xx.'               '.'                       64 * 0
# 128       'xxx'               'x'                      128 * 1
#                                                      ----------
#                                                           142

# To calculate the patterns which will have the central character x, work
# out the values required to sum to the pattern number. For example,
# 32 = 32 so only pattern 32 which is x.x changes the central position to
# an x. All the others have a . in the next line.

# 23 = 16 + 4 + 2 + 1 which means that 'x..', '.x.', '..x' and '...' all
# lead to an 'x' in the next line and the rest have a '.'

# For pattern 142, and starting string
# ...........x...........
# the new strings created will be
# ..........xx...........  (generations = 1)
# .........xx............  (generations = 2)
# ........xx.............  (generations = 3)
# .......xx..............  (generations = 4)
# ......xx...............  (generations = 5)
# .....xx................  (generations = 6)
# ....xx.................  (generations = 7)
# ...xx..................  (generations = 8)
# ..xx...................  (generations = 9)
# .xx....................  (generations = 10)

# Note that the first position of the string is next to the last position
# in the string.

# Define a procedure, cellular_automaton, that takes three inputs:
#     a non-empty string,
#     a pattern number which is an integer between 0 and 255 that
# represents a set of rules, and
#     a positive integer, n, which is the number of generations.
# The procedure should return a string which is the result of
# applying the rules generated by the pattern to the string n times.

# If the plotter argument is set to 'on' (default value), then the output string of every generation is printed.

def cellular_automaton(string, pattern_number, generations, plotter='on'):
    pattern_dict = {}
    pattern_list = ['...', '..x', '.x.', '.xx', 'x..', 'x.x', 'xx.', 'xxx']
    string_length = len(string)

    # Creating a pattern dictionary for the corresponding pattern number
    for pow2 in range(7, -1, -1):
        if pattern_number // (2**pow2) == 1:
            pattern_dict[pattern_list[pow2]] = 'x'
            pattern_number %= (2**pow2)
        else:
            pattern_dict[pattern_list[pow2]] = '.'

    # Generating the new string resulting from applying the pattern to the input string
    if plotter == 'on':
        print(string)
    for generation in range(generations):
        new_string = ''
        for idx in range(-1, string_length-1, 1): # We start from the end of the string
            element_1 = string[(idx % string_length)] # 1st element of a triplet
            element_2 = string[(idx + 1) % string_length] # 2nd element of a triplet
            element_3 = string[(idx + 2) % string_length] # 3rd element of a triplet
            triplet = element_1 + element_2 + element_3 # Where each triplet is an element of the pattern_list
            new_string += pattern_dict[triplet]
        if plotter == 'on':
            print(new_string)
        string = new_string # See ====NOTES ON INPUT ARGUMENT UPDATING==== below

    return new_string


####################
#      TESTS       #
####################


print(cellular_automaton('.x.x.x.x.', 17, 2, 'off'))
print(' \n ')
print(cellular_automaton('.x.x.x.x.', 17, 5, 'on'))
print(' \n ')
print(cellular_automaton('.x.x.x.x.', 249, 3, 'off'))
print(' \n ')
print(cellular_automaton('.x.x.x.x.', 249, 3, 'on'))
print(' \n ')
print(cellular_automaton('...x....', 125, 8, 'off'))
print(' \n ')
print(cellular_automaton('...x....', 125, 8))
print(' \n ')
cellular_automaton('...x....', 125, 10)
print(' \n ')
cellular_automaton('....................x....................', 126, 100)



# ====NOTES ON INPUT ARGUMENT UPDATING====
# A variable referencing to an updated input argument is NOT automatically updated,
# unless it is explicitly re-assigned to the updated input argument. In this script, the variable <string_length>
# is not updated (although, in this example we don't need to update it, as string length remains the same throughout).

# In contrast, wherever you explicitly refer to the updated input argument IN THE
# CORRECT ORDER OF OPERATION, you do get the updated value of the argument. So the variables:
# <element_1>, <element_2> & <element_3> are all updated.

# Run the code below to better understand this idea.

# def printer(inn):
#     length = len(inn)
#     print(length)
#     print(inn)
#     inn = 'The input to the function has been modified by the function itself'
#     print(inn)
#     print(length)
#     print(len(inn))
#
# printer('this')

